import json
import argparse
desc="DYPIU - Web Vulnerability Scanner"
parser=argparse.ArgumentParser(description=desc)
parser.add_argument("action",help="Action: full xss sql fuzzing e-mail credit-card whois links portscanner urlEncode cyberthreatintelligence commandInjection directoryTraversal fileInclude headerCheck certificate method IP2Location FileInputAvailable")
parser.add_argument("web_URL",help="URL")
args = parser.parse_args()
url=""
import ssl
import socket
import telnetlib3 as telnetlib
import requests
import re
from requests.packages.urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
from urllib.parse import urlparse
from urllib.parse import quote

def to_urlencoded_string(input_string):
    return quote(input_string)
def isLocalHost(url):
    return urlparse(url).hostname == "localhost"

# #function to extract domain from url
# def extract_domain(url):
#     print(url)
#     pattern = r"https?://(?:www\.)?([a-zA-Z0-9.-]+)"
#     match = re.search(pattern, url)

#     if match:
#         # Extract the domain from the matched group
#         domain = match.group(1)
#         return domain
#     else:
#         print(json.dumps({"type":"invalidUrl", "message":f"Invalid URL: {url}"}))
#         return None
# import re

def convert_to_url(domain):
    if not re.match(r"^[a-zA-Z0-9.-]+$", domain):
        raise ValueError("Invalid domain format")
        print(json.dumps({"type":"invalidUrl", "message":f"Invalid URL: {url}"}))

    url = f"https://www.{domain}"
    return url

import whois

def whoisSorgu(url):
    try:
        query = whois.whois(url)
        domain = str(query.domain)
        print(json.dumps({"type":"result", "message":f"Domain for {url} is {domain}", "service":"whois"}))
        updated_date = str(query.get('updated_date'))
        print(json.dumps({"type":"result", "message":f"Last update Date : {updated_date}", "service":"whois"}))
        expiration_data = str(query.get('expiration_date'))
        print(json.dumps({"type":"result", "message":f"Expiration Date : {expiration_data}", "service":"whois"}))
        name_servers = str(query.get('name_servers'))
        print(json.dumps({"type":"result", "message":f"Name Servers : {name_servers}", "service":"whois"}))
        email = str(query.get('emails'))
        print(json.dumps({"type":"result", "message":f"Email : {email}", "service":"whois"}))


    except Exception as e:
        # return {"Error": str(e)}
        print(json.dumps({"type":"error", "message":f"Got into error while doing whois lookup.", "service":"whois", "value":e}))






from datetime import datetime

def certificate_information(url):
    result = {}

    try:
        print(json.dumps({"type":"realTimeUpdate", "service":"certificate", "message":"Fetching SSL Certificate Information"}))
        
        # Create SSL context and establish connection
        context = ssl.create_default_context()
        server = context.wrap_socket(socket.socket(), server_hostname=url)
        server.connect((url, 443))
        
        # Get the certificate
        certificate = server.getpeercert()
        
        if certificate:
            # Check the validity period
            not_before = datetime.strptime(certificate['notBefore'], '%b %d %H:%M:%S %Y %Z')
            not_after = datetime.strptime(certificate['notAfter'], '%b %d %H:%M:%S %Y %Z')
            current_time = datetime.utcnow()

            if not_before <= current_time <= not_after:
                validity_status = "Valid"
            else:
                print(json.dumps({"type":"vulnerability", "message":f"SSL Certificate Not Valid."}))
                return

            # Verify hostname (you can use ssl.match_hostname for this)
            try:
                ssl.match_hostname(certificate, url)
                hostname_status = "Hostname matches"
            except ssl.CertificateError as ce:
                hostname_status = f"Hostname does not match: {ce}"
                print(json.dumps({"type":"vulnerability", "message":f"SSL Certificate Not Valid."}))
                return

            print(json.dumps({"type":"result", "message":f"SSL Certificate Present and {validity_status}. Hostname verification: {hostname_status}", "service":"certificate", "certificate": certificate}))
        else:
            print(json.dumps({"type":"vulnerability", "message":f"SSL Certificate Not Present.", "service":"certificate", "value":certificate}))

    except Exception as e:
        print(json.dumps({"type":"error", "message":f"Error fetching certificate information: {e}", "service":"certificate", "value":str(e)}))




def convert_url(url):
    if not url.startswith("http://") and not url.startswith("https://"):
        return "http://" + url
    return url

def headerInformation(url):
    url = convert_url(url)
    try:
        sonuc = requests.get(url, verify=False)
        headers_to_check = {
            'Content-Security-Policy': 'CSP header',
            'Strict-Transport-Security': 'HSTS header',
            'X-Frame-Options': 'X-Frame-Options header',
            'X-Content-Type-Options': 'X-Content-Type-Options header',
            'Referrer-Policy': 'Referrer-Policy header',
            'Permissions-Policy': 'Permissions-Policy header',
            'X-XSS-Protection': 'X-XSS-Protection header',
            'Expect-CT': 'Expect-CT header',
            'Cross-Origin-Resource-Policy': 'Cross-Origin-Resource-Policy header',
            'Cross-Origin-Opener-Policy': 'Cross-Origin-Opener-Policy header',
            'Cross-Origin-Embedder-Policy': 'Cross-Origin-Embedder-Policy header'
        }
        
        for header, description in headers_to_check.items():
            if header not in sonuc.headers:
                print(json.dumps({"type": "warning", "service": "headerInformation", "message": f"{description} is missing."}))
            else:
                print(json.dumps({"type": "result", "service": "headerInformation", "message": f"{description} found: " + sonuc.headers[header]}))

    except Exception as e:
        print(json.dumps({"type": "error", "service": "headerInformation", "message": "Unable to detect Security Headers.", "error": str(e)}))

import socket
def port_scanner(url):
    common_ports = [
    20, 21, 22, 23, 25, 53, 67, 68, 69, 80, 
    110, 111, 123, 137, 138, 139, 143, 161, 162, 179, 
    194, 201, 389, 443, 445, 464, 465, 514, 515, 520, 
    523, 548, 554, 587, 631, 636, 873, 902, 989, 990, 
    993, 995, 1025, 1080, 1194, 1352, 1433, 1434, 1512, 1521, 
    1723, 1812, 1813, 2049, 2082, 2083, 2483, 2484, 3306, 3389
]
    start_port=20
    end_port = 26

    try:
        isLocal = isLocalHost(url)
        if isLocal:
            print(json.dumps({"type":"result", "message":f"Target is Local Host,  skipping port scan."}))
            return

        target_ip = socket.gethostbyname(url)
        print(json.dumps({"type":"result", "message":f"Discovred Target ipv4 address : {target_ip}"}))
        # print(json.dumps({"type":"realTimeUpdate", "message":f"Scanning ports for {url} ({target_ip}) in the range {start_port} to {end_port}"}))
        for port in common_ports:
            print(json.dumps({"type":"realTimeUpdate", "message":f"Scanning Port {port}."}))
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            result_code = sock.connect_ex((target_ip, port))
            if result_code == 0:
                print(json.dumps({"type": "warning", "service": "portScanner", "message": f"Port {port} is open"}))
            sock.close()
    except socket.gaierror:
        print(json.dumps({"type": "error", "service": "portScanner", "value": port, "message": "Error: Couldn't resolve the host."}))
    except socket.error:
        print(json.dumps({"type": "error", "service": "portScanner", "value": port, "message": "Error: Couldn't connect to the server."}))
    except KeyboardInterrupt:
        print(json.dumps({"type": "error", "service": "portScanner", "value": port, "message": "Scan interrupted."}))

def get_ip_location(url):
    isLocal = isLocalHost(url)
    if isLocal:
        print(json.dumps({"type":"result", "message":f"Target is Local Host,  skipping IP location."}))
        return
    api_url = "http://ip-api.com/json/" + url
    try:
        print(json.dumps({"type":"realTimeUpdate", "service":"IP2Location", "message":"Getting Location via IP address."}))
        response = requests.get(api_url, verify=False)
        data = response.json()
        print(json.dumps({"type":"result", "service":"IP2Location", "message":"Location fetched successfully.", "value":"Server Location: " + data.get('country') + ", " + data.get('city')}))
    except Exception as e:
        print(json.dumps({"type":"error","service":"IP2Location", "message":"Error while fetching location", "value":e}))

def fileInclude(url):
    result = {
        "Status": "",
        "Payload": "../../../../../../etc/passwd",
        "Response": ""
    }

    try:
        deger = url.find("=")
        istek = url[:deger + 1] + "../../../../../../etc/passwd"
        sonuc = requests.get(istek, verify=False)

        if "www-data" in sonuc.content:
            print(json.dumps({"type":"result", "service":"fileInclude", "message":"File include possible"}))
            result["Status"] = "[+]File include possible"
        else:
            print(json.dumps({"type":"result", "service":"fileInclude", "message":"File include isn't possible"}))
            result["Status"] = "[-]File include isn't possible"

    except Exception as e:
        print(json.dumps({"type":"result","service":"fileInclude", "message":"Path injection not detected"}))
        




import requests
def sql_injection_scan(url):
    print(json.dumps({"type":"realTimeUpdate", "service":"sqlInjection", "message":"Testing SQLi payload."}))
    isLocal = isLocalHost(url)
    if isLocal:
        url = url
    else:
        url = convert_to_url(url)
    result = {
        "Target": url,
        "Vulnerabilities": []
    }

    sql_payloads = [
        "%' or '1'='1",
    ]
    if "=" in url:
        param_index = str(url).find('=')

        for payload in sql_payloads:
            try:
                payload = to_urlencoded_string(payload)
                modified_url = str(url[:param_index + 1]) + str(payload)+"&Submit=Submit#"
                print(modified_url)
                response = requests.get(modified_url)
                print("SQL response is : ", response.status_code)
                if int(response.status_code) == 200:
                    print(json.dumps({"type":"vulnerability", "service":"sqlInjection", "message":"SQLi payload is vulnerable.", "value":{"payload": str(payload), "url": modified_url}}))

            except Exception as e:
                print(json.dumps({"type":"error","service":"sqlInjection", "message":"Error while testing SQLi payload", "value":e}))
                continue

    else:
        print(json.dumps({"type":"realTimeUpdate", "service":"sqlInjection", "message":"URL doesn't contain any parameter.", "value":result}))

    print(json.dumps({"type":"result", "service":"sqlInjection", "message":"SQLi scan completed.", "value":result}))

import requests
def xss_scan(url):
    xss_payloads = [
        '<sCript>alert("XSS")</sCript>',
    ]

    result = {
        "Target": url,
        "Vulnerabilities": []
    }

    equals_index = url.find("=")
    param_index = str(url).find('=')
    if "=" in url:
        for payload in xss_payloads:
            try:
                print("Payload is : ", payload)
                modified_url = str(url[:param_index + 1]) + str(payload)
                print(modified_url)
                response = requests.get(modified_url)
                if int(response.status_code) == 200:
                    print(json.dumps({"type":"vulnerability", "service":"xss", "message":"XSS payload is vulnerable.", "value":{"payload": payload, "url": modified_url}}))
            except Exception as e:
                continue
    else:
        print(json.dumps({"type":"realTimeUpdate", "service":"xss", "message":"URL doesn't contain any parameter.", "value":result}))

    print(json.dumps({"type":"result", "service":"xss", "message":"Finished scanning for XSS vulnerabilities."}))


def commandInjection(url):
    print(json.dumps({"type":"realTimeUpdate", "service":"commandInjection", "message":"Scanning for command injection vulnerability"}))
    try:
        deger = url.find("=")
        istek = url + ";cat%20/etc/passwd"
        sonuc = requests.get(istek, verify=False)
        response = sonuc.content.decode('utf-8')
        if "www-data" in response:
            print(json.dumps({"type":"vulnerability","service":"commandInjection", "message":"Command Injection Vulnerability Detected", "value":";cat%20/etc/passwd"}))
        print(json.dumps({"type":"result", "service":"commandInjection", "message":"Command Injection not detected"}))
    except Exception as e:
        print(json.dumps({"type":"result", "service":"commandInjection", "message":"Command Injection not detected"}))

def directoryTraversal(url):
    try:
        deger = url.find("=")
        
        istek = url[:deger + 1] + "../../../../../../etc/passwd"
        sonuc = requests.get(istek, verify=False)
        response = sonuc.content.decode('utf-8')
        if "www-data" in response:
            print({json.dumps({"type":"vulnerability","service":"directory traversal", "value":"../../../../../../etc/passwd","message":"Directory Traversal Vulnerability Detected"})})
        else:
            print(json.dumps({"type":"result","service":"directory traversal", "message":"Directory Traversal Vulnerability Not Detected"}))
    except Exception as e:
        print(json.dumps({"type":"result","service":"directory traversal","message":"Directory Traversal Vulnerability Not Detected"}))


if args:
    url = getattr(args, 'web_URL')
    if args.action=="sql":
        sql_injection_scan(url)

    elif args.action=="whois":
        whoisSorgu(url)

    elif args.action=="portscanner":
        port_scanner(url)

    elif args.action=="urlEncode":
        url_encode(url)

    elif args.action=="xss":
        xss_scan(url)

    elif args.action=="e-mail":
        extract_emails(url)

    elif args.action=="credit":
        check_credit_cards(url)

    elif args.action=="links":
        extract_links(url)

    elif args.action=="commandInjection":
        commandInjection(url)

    elif args.action=="directoryTraversal":
        directoryTraversal(url)

    elif args.action=="fileInclude":
        fileInclude(url,dosyaAdi)

    elif args.action=="headerCheck":
        headerInformation(url)

    elif args.action=="certificate":
        if str(url).split("/")[2]:
            url=str(url).split("/")[2]
        elif str(url).split("/")[3]:
            url = str(url).split("/")[2]
        certificate_information(url)

    elif args.action=="method":
        if str(url).split("/")[2]:
            url=str(url).split("/")[2]
        elif str(url).split("/")[3]:
            url = str(url).split("/")[2]
        get_http_methods(url)

    elif args.action=="IP2Location":
        get_ip_location(url)


    elif args.action=="full":
        print(json.dumps({"type":"info", "message":"Starting full scan..."}))
        whoisSorgu(url)
        certificate_information(url)
        headerInformation(url)
        port_scanner(url)
        get_ip_location(url)
        fileInclude(url)
        sql_injection_scan(url)
        xss_scan(url)
        commandInjection(url)
        directoryTraversal(url)
        print(json.dumps({"type":"info","message":"Full Scan Completed"}))
    else:
        exit()